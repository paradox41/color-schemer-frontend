import TheirClass from "./mypath";
import {identifier, otherIdentifier} from "somewhere";

import thing, {identifier as otherIdentifier}, * as otherName from "otherplace";
import 'module'

let a = { otherIdentifier, foo(), baz: 1 }
someFunction({
    prop1, prop2, prop3
});

function foo() {
}

var bar = function() {
}

baz = function*()
{

}

if (true)
{
    bar()
}

// This is a comment function() { }

var str = ':';
var str2 = 0;

tag`Hello ${ a + b } world\nanother ${expression}.`;

mylabel:

true ? str : str2

a = test ? a + b : c;

{{foo}}
{{#bar}}{{/bar}}

var obj = {
    key: bar,
    $key2: "string value",
    $key3: 0,
    $keyFunc: function() {
    }

    "key4": true,
    'key5': true,

    funcKey: function() {
    },

    func2Key: function func2Key() {
    },

    funcKeyArrow: () => {
    },

    "funcStringKey": function funcStringKey()
    { },

    'funcStringKey': function() {
    },

    'funcStringKeyArrow': () => {
    },

    "func\\String2KeyArrow": (foo) => {
    },

    key: 'str' + (true ? 'true' : 'false'),

    qux()
    {}

    static foo(bar) {
    }

    *baz(){
    }
}

var $ = function(baz) {
}

$()

$foo = null;

baz = "";

var qux = 100;

if (100.0 > qux) {
    a;
}

if (foo bar)
    baz = "test"

do {
    qux += 1
} while(qux < 20);

for (var i = 0; i < 10; i++) {
    i += 1;
}

while (true)
{
    break;
}

switch ($foo) {
    case foo:
        qux = 1;
        break;
    case "baz":
        qux = 2;
        break;
    default:
        qux = 3;
}

try {
    foobar = qux.bar();
} catch (e) {
    foobar = 0
} finally {
    foobar += 1
}

class MyClass extends TheirClass {
    constructor(el)
    {
        $.foo = "";
        super(el);
    }

    get foo()
    {
        return this._foo;
    }

    static foo(baz) {

    }

    qux()
    { }

    get bar () {
        return false;
    }

    baz() { return null }
}

class Foo extends React.Component {
    constructor()
    {}
}

() => {}

MyClass.foo = function() {}

MyClass.foo = () => {}

xhr.onload = function() {}

xhr.onload = () => {}

var simpleArrow = foo => bar

var Proto = () => {
    this._var = 1;
}

Proto.prototype.getVar = () => this._var

Class3.prototype = function() {
}

Proto.prototype.attr

Proto.prototype = {
    funcName: function() {
    }
}

sources.DOM.status()
sources.DOM
    .status()

return new Promise(resolve => preferenceObject.set({value}, resolve));

var anotherSingle = function(){a = param => param; return param2 => param2 * a}

baz(foo(x => x('bar')))

func(a, b)

var instance = new Constructor(param1, param2)

this.func()
self.func()

var Constructor = function() {
    this._var = 1;
    this._method = function() {}
}

var abc = new ABC(
    'my-name-is-abc',
    new (function () {
        var foo = 1;
    })
);

new Date().getTime()

void {
    'test1': [],
    'test2': new SomeOjbectHash["default"],
    'test3': "asdf"
}

void {
    key1: true
    key2: 0
    key3: function()
    {

    }
}

a = b.c
d = e.f

width/2 + lineStart * Math.sin(i * 30 * π/180)

var reg = /a+/gimy.exec('aabb')

'aabbcc'.replace(/b+/, 'd')

/a+/

'foo'.bar() / baz

var g = 50

g / 20 + 30 /g

var h = foo() / 20 + 30 /g

foo['bar']/ 20 + 30 /g

var result = 200 / 400 + 500 /
100;

var re = /
[a-z]
/g

var π = 3.141592653

var angle = 2*π / count // angle between circles

var angle = 2*π / count /* angle between circles */

a = /foo\/bar/g // Ensure handling of escape / in regex detection

var re = /^\/[^/]+/

(y - 1) / ((x - 1) / -2)
(y - 1) / ((x - 1) /  2)
 y      / ((x - 1) / -2)

define(['common'], function(common) {
    var namedFunc = function() {
    }
});

new FooBar(function(){
    var namedFunc2 = function() {
    }
})

['foo'].bar = function() {
}

['foo'].$ = function() {
}

['foo'].$bar = function() {
}

{
    let foo = 1;
}

var test =
{a: 1}

var conciseFunc = () =>
  foo
  .bar()

(myFunc = (a) => a*2)

var o = { a: i => i * 2, b: i => i * 3 }

$.each({})

$varname.method()

$.fn.new_plugin = function() {}

$var.fn.name = () => {}

someFunction(() => [() => 'X']);
